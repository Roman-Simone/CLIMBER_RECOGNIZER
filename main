from PIL import Image, ImageTk
import tkinter as tk
import cv2
from utils import *
import numpy as np

# Global variable
dim_x_window = 1200
dim_y_window = 800
path_img = "Media/2_image_lead.jpg"
width_img = 0
height_img = 0
start_x = 0
start_y = 0
finish_x = 0
finish_y = 0
is_cropped = False
colorRGB_route = (0, 0, 0)
colorHSV_route = (0, 0, 0)


# Create window
window = tk.Tk()
window.title("CLIMBER RECOGNIZER")
window.geometry(f"{dim_x_window}x{dim_y_window}")

# Read the image
cv_img = cv2.cvtColor(cv2.imread(path_img), cv2.COLOR_BGR2RGB)
original_image_cv = cv_img.copy()


def resize_img(win_width, win_height, width, height):
    win_width = int(win_width)
    win_height = win_height

    if width > height:
        scalingfactor = win_width/width
        new_width = win_width
        new_height = int(height*scalingfactor)
    else:
        scalingfactor = win_height/height
        new_height = win_height
        new_width = int(width*scalingfactor)
    
    return new_width, new_height

def on_resize(event):
    global cv_img, original_image_cv
    # Questa funzione viene chiamata quando la finestra viene ridimensionata

    height, width ,_= original_image_cv.shape
    new_w, new_h = resize_img(window.winfo_width(), window.winfo_height(), width, height)
    cv_img = cv2.resize(original_image_cv, (new_w, new_h), interpolation=cv2.INTER_LANCZOS4)
    image_tk = Image.fromarray(cv_img)

    # Converti l'immagine in formato Tkinter
    PhotoImage = ImageTk.PhotoImage(image_tk)

    # Aggiorna l'immagine nel canvas
    canvas.config(width=new_w, height=new_h)
    canvas.imgref = PhotoImage

    canvas.itemconfig(prova, image=PhotoImage)

# Funzione per ottenere il colore al click sull'immagine
def get_color(event):
    
    global start_x, start_y, cv_img, is_cropped, colorRGB_route, colorHSV_route

    if not is_cropped:
        start_x = event.x
        start_y = event.y
    else:
        x, y = event.x, event.y
        hsv_img = cv2.cvtColor(cv_img, cv2.COLOR_RGB2HSV)
        r, g, b = cv_img[y, x]
        h, s, v = hsv_img[y, x]
        # Crea un quadrato dello stesso colore
        colorRGB_route = (r, g, b)
        colorHSV_route = (h, s, v)
        square_size = 100
        square_image = Image.new('RGB', (square_size, square_size), colorRGB_route)
        square_photo = ImageTk.PhotoImage(square_image)
        square_canvas.create_image(0, 0, image=square_photo, anchor=tk.NW)
        square_canvas.image = square_photo

# Event handlers for the buttons
def button_cropIMG():
    global start_x, start_y, finish_x, finish_y, cv_img, is_cropped, original_image_cv
    
    if not is_cropped:
        
        height, width ,_= original_image_cv.shape
        new_w, new_h = resize_img(window.winfo_width(), window.winfo_height(), width, height)
        
        cv_img = cv_img[start_y:finish_y, start_x:finish_x]
        original_image_cv = cv_img.copy()
        height, width ,_= original_image_cv.shape
        new_w, new_h = resize_img(window.winfo_width(), window.winfo_height(), width, height)
        cv_img = cv2.resize(original_image_cv, (new_w, new_h), interpolation=cv2.INTER_LANCZOS4)
        # Convert the image to PIL format
        image_tk = Image.fromarray(cv_img)

        # Convert the image to Tkinter format
        PhotoImage = ImageTk.PhotoImage(image_tk)

        # Aggiorna l'immagine nel canvas
        canvas.config(width=new_w, height=new_h)
        canvas.imgref = PhotoImage

        canvas.itemconfig(prova, image=PhotoImage)
        canvas.delete("rectangle")
        is_cropped = True

def button_findRoute():
    global cv_img, colorHSV_route

    hsv_img = cv2.cvtColor(cv_img, cv2.COLOR_RGB2HSV)

    h = colorHSV_route[0]

    lower_range = (int(h-5), 50, 50) # lower range of red color in HSV
    upper_range = (int(h+5), 255, 255) # upper range of red color in HSV

    mask = cv2.inRange(hsv_img, lower_range, upper_range)
    color_image = cv2.bitwise_and(hsv_img, hsv_img, mask=mask)

    # Apply Canny edge detection
    edges = cv2.Canny(color_image, 50, 150)

    # Dilate the edges to improve contour detection
    kernel = np.ones((3, 3), np.uint8)
    dilated_edges = cv2.dilate(edges, kernel, iterations=1)

    # Find contours
    contours, _ = cv2.findContours(dilated_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours by area and non-hollow contours
    filtered_contours = []
    for cnt in contours:
        if cv2.contourArea(cnt) > 50:
            filtered_contours.append(cnt)

    # Draw contours on the color image
    cv2.drawContours(cv_img, filtered_contours, -1, (0, 255, 0), 2)
    # cv_img = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
    image_tk = Image.fromarray(cv_img)

    # Converti l'immagine in formato Tkinter
    PhotoImage = ImageTk.PhotoImage(image_tk)
    canvas.imgref = PhotoImage
    canvas.itemconfig(prova, image=PhotoImage)

    # # Display the color image and edges
    save("Color_img", [cv_img, edges])

def update_rectangle(event):
    global start_x, start_y, finish_x, finish_y, is_cropped
    if not is_cropped:
        finish_x = event.x
        finish_y = event.y
        canvas.delete("rectangle")
        canvas.create_rectangle(start_x, start_y, finish_x, finish_y, outline="red", tags="rectangle")


window.rowconfigure(1, weight=1)
window.rowconfigure(2, weight=1)
window.rowconfigure(3, weight=1)
window.rowconfigure(4, weight=1)
window.columnconfigure(1, weight=1)
window.columnconfigure(2, weight=1)

# Open Image
height, width ,_= cv_img.shape
image_tk = Image.fromarray(cv_img)
# Convert the image to Tkinter format
PhotoImage = ImageTk.PhotoImage(image_tk)

# Crea un frame per l'immagine
image_frame = tk.Frame(window)
# image_frame.grid(row=1, column=1, sticky="nsew")
image_frame.pack(side=tk.LEFT)
# Crea un canvas per l'immagine
canvas = tk.Canvas(image_frame, background="blue")
# canvas.grid(row=1, column=1, sticky="nsew")
canvas.pack()
# Aggiungi l'immagine al canvas
prova = canvas.create_image(0, 0, image=PhotoImage, anchor=tk.NW)
# Aggiungi la funzione di callback al click sull'immagine
canvas.bind('<Configure>', on_resize)
canvas.bind("<Button-1>", get_color)


canvas.bind("<B1-Motion>", update_rectangle)

# Create a frame
frame = tk.Frame(window)
# frame.pack(expand=True, fill="both", side="right")
# frame.grid(row=1, column=2, sticky="nsew")
frame.pack()

label_title = tk.Label(frame, text="ROUTE RECOGNIZER", font=("Arial", 20, "bold"))
label_title.pack()

# Create two buttons
button1 = tk.Button(frame, text="CROP IMAGE", command=button_cropIMG)
# button1.pack(pady=10)
# button1.grid(row=1, column=2)
button1.pack()
label_btn1 = tk.Label(frame, text="Color: ")
# label_btn1.grid(row=2, column=2)
label_btn1.pack()


label_btn2 = tk.Label(frame, text="Click the image to choose the color hold:", font=("Arial", 12))

# label_btn2.grid(row=4, column=2)
label_btn2.pack()
# Crea un canvas per il quadrato
square_canvas = tk.Canvas(frame, width=100, height=100)
colorRGB_route = (149, 20, 6)
square_size = 100
square_image = Image.new('RGB', (square_size, square_size), colorRGB_route)
square_photo = ImageTk.PhotoImage(square_image)
square_canvas.create_image(0, 0, image=square_photo, anchor=tk.NW)
square_canvas.image = square_photo
square_canvas.pack()
button2 = tk.Button(frame, text="DRAW THE LINE", command=button_findRoute)

button2.pack()

window.mainloop()